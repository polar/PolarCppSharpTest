
# The platform that we are building on. We only consider two, linux, or windows.
def build_platform
  RUBY_PLATFORM =~ /linux/ ? "linux" : "win"
end

# The build architecture is always x64 for now.
def build_arch
  "x64"
end

def cpp_sharp_home
  ENV["CPPSHARP_HOME"] || (build_platform == "linux" ? "#{ENV["HOME"]}/src/CppSharp" : "/devel/src/CppSharp")
end

def writeFile(file, content)
  fd = File.open(file, "w+")
  fd.write(content)
  fd.close
end

# This method produces the CppSharp CLI command
# for bash(linux) or cmd(windows) as we have to run on the build platoform.
def cpp_sharp_cli
  # TODO: Put our version of the CppSharp tool somewhere public.
  if build_platform =~ /linux/
    # On linux CppSharp is made with gmake, and we must use mono.
    cli = "mono --debug #{cpp_sharp_home}/build/gmake/lib/Release_x64/CppSharp.PolarCLI.exe"
  else
    # On Windows CppSharp is built with vs2017 natively.
    cli = "#{cpp_sharp_home}/build/vs2017/lib/Release_x64/CppSharp.PolarCLI.exe"
  end
  cli
end

def generate(output_dir, platform, arch, files)
  dest = "#{output_dir}/#{platform}/#{arch}"
  sh gencmd(output_dir, platform, arch, files)
  # We need to massage the resultant files.
  # The #include directives have full paths in them, and we need to make them relative to its directory.
  # We'll just do it in memory. The Std.cs and symbols.cpp files aren't that large.
  if platform == "linux"
    # This symbol comes up wrong for linux ABI some reason. Easy enough, we just change it.
    # TODO:: Find out why generated basic_string symbol is wrong.
    symbols = File.open("#{dest}/Std.cs").read.gsub("_ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4dataEv",
                                                    "_ZNKSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE4dataEv")
    writeFile("#{dest}/Std.cs", symbols)
  else
    # This symbol comes up wrong for linux ABI some reason. Easy enough, we just change it.
    # TODO:: Find out why generated data@?$basic_string symbol is wrong.
    symbols = File.open("#{dest}/Std.cs").read.gsub("?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ",
                                                    "?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ")
    # Other corrections!
    symbols = symbols.sub(/namespace _Vector_val[\s][^}]*}\s*}/, File.read("Template/Vector_val.cs.in"))
    symbols = symbols.sub(/namespace _String_val[\s][^}]*}[^}]*}\s*}\s*}/, File.read("Template/String_val.cs.in"))
    writeFile("#{dest}/Std.cs", symbols)
  end
end

def getTestClass(file)
  content = File.read(file)
  content.match(/public unsafe partial class Test(\s*[^}])*}/).to_s
end

def replaceTestClass(file, new_content)
  content = File.read(file)
  content.sub!(/public unsafe partial class Test(\s*[^}])*}/, new_content)
  writeFile(file, content);
end

def fixTestClass(file)
  content = getTestClass(file)
  content = content.sub("FieldOffset(32)", "FieldOffset(40)")
                   .sub("FieldOffset(64)", "FieldOffset(80)")
                   .sub("FieldOffset(96)", "FieldOffset(120)")
  replaceTestClass(file, content)
end

# only for windows
task :fix => ["Generated/#{build_platform}/x64/ALK.cs"] do 
  fixTestClass("Generated/#{build_platform}/x64/ALK.cs")
  puts getTestClass("Generated/#{build_platform}/x64/ALK.cs")
end

def gencmd(output_dir, platform, arch, files)

    vector_holder_path = File.expand_path("CppAPI/Interop/VectorHolder.hpp")
    optional_path = File.expand_path("CppAPI/Interop/Optional.hpp")
    
    options = "-DGENERATE"
    cflags = ""
    #
    # We are just going with options at this point. CFlags don't mean much here.
    #
    dest = "#{output_dir}/#{platform}/#{arch}"
    cmd = "#{cpp_sharp_cli} "
    cmd << "--p=#{platform} --a=#{arch} "
    cmd << "--on=ALK "                                             # Output namespace
    cmd << "--ON=Interop::Optional --O=#{optional_path} "          # Name and path of class Optional
    cmd << "--VN=Interop::VectorHolder --V=#{vector_holder_path} " # Name and path of class VectorHolder
    cmd << "--o=#{dest} "                                          # output directory for generated files
    cmd << options << " "                                          # Compiler Options from above.
    cmd << files.join(" ")                                         # Include files
    cmd
end

directory("Generated")

file "Generated/#{build_platform}/#{build_arch}/ALK.cs" => FileList["Generated", "Includes.hpp", "CppAPI/**/*.hpp"] do
    generate("Generated", build_platform, build_arch, ["Includes.hpp"])
end

desc "Generates the ALK.Interop.cs file and the symbols"
task :generate => ["Generated", "Generated/#{build_platform}/#{build_arch}/ALK.cs"]

task :gen => [:generate]

task :clean do
  rm_rf "cmake-#{build_platform}-build"
  rm_rf "Generated"
end

task :regen => [:clean, :generate]

directory("cmake-#{build_platform}-build")

file "cmake-linux-build/CMakeCache.txt" => ["cmake-linux-build", "CMakeLists.txt", "Generated/linux/x64/ALK.cs"] do
  Dir.chdir("cmake-linux-build") do
    sh "cmake .."
  end
end

file "cmake-win-build/CMakeCache.txt" => ["cmake-win-build", "CMakeLists.txt", "Generated/win/x64/ALK.cs"] do
  Dir.chdir("cmake-win-build") do
    # If it's not already built we build Debug.
    sh "cmake -GNinja .."
  end
end

file "bin/Debug/netcoreapp3.1/ALK.dll" => FileList["cmake-win-build/CMakeCache.txt", "CppAPI/**/*.?pp"] do
  Dir.chdir("cmake-win-build") do
    sh "ninja install"
  end
end

file "bin/Debug/netcoreapp3.1/libALK.so" => FileList["cmake-linux-build/CMakeCache.txt", "CppAPI/**/*.?pp"] do
  Dir.chdir("cmake-linux-build") do
    sh "make install"
  end
end

library = build_platform == "linux" ? "bin/Debug/netcoreapp3.1/libALK.so" : "bin/Debug/netcoreapp3.1/ALK.dll"

task :install => [library]

task :run => [:install] do
  sh "dotnet run"
end